package preprocessing;

import javafx.util.Pair;

import java.io.*;
import java.util.*;

/**
 * Created by Katerina Intzevidou on 10-May-17.
 * Email: <aintzevi@csd.auth.gr> <intz.katerina@gmail.com>
 */
public class FileOperations {
    String inputFilename;
    String outputFilename;

    public FileOperations(String inputFilename, String outputFilename) {
        this.inputFilename = inputFilename;
        this.outputFilename = outputFilename;
    }

    /**
     * Reads raw data from a file containing SNP information (like SNP id, score, rank, etc) (File generated by TRES)
     * and puts every line in a list
     * @return List with the raw data as a String
     */
    private List<String> ReadFromFile() {
        // List to save the file contents
        List<String> fileLinesContents = new ArrayList<>();
        // String to save each line
        String line;

        // Create a file handle on the filename of the input
        File inputFile = new File(inputFilename);
        // Create buffered reader
        BufferedReader reader = null;

        try {
            // Connect reader with input file
            reader = new BufferedReader(new FileReader(inputFile));

            // Init line variable to space
            line = "";
            // While there still are lines in the file to read
            while (line != null) {
                // Add line into the string array list
                fileLinesContents.add(line);
                // Read the next line, store in variable line
                line = reader.readLine();
            }

            // Close reader after it has been read
            reader.close();
        } catch (IOException e) {
            System.out.println("Buffered reader init failed");
            e.printStackTrace();
        }
        finally {
            // Closing the reader
            try {
                // Checking if the reader is still open
                if (reader != null)
                    // If so, close it
                    reader.close();
            } catch (IOException ex) {
                System.out.println("Error closing buffered reader");
                ex.printStackTrace();
            }
        }
        // Return list with file contents
        return fileLinesContents;
    }

    /**
     * Reads the raw data from a list of Strings and turns them into SNP format (Check SNP doc)
     * @return List of SNPs
     */
    private List<SNP> FileLinesListToSNPList() {
        // List to be transformed -- Contains raw input data
        List<String> fileLinesArrayList = new ArrayList<>(this.ReadFromFile());

        // Remove 11 first items from the list -- Useless text
        for (int i = 0; i < 11; ++i) {
            // Always removing the first item, since after every removal the contents are shifted one space back
            fileLinesArrayList.remove(0);
        }

        // Create SNP List
        List<SNP> SNPList = new ArrayList<>();

        // Iterating through each list string
        for (String currentLine : fileLinesArrayList) {
            // SNP that will be created by the current line of input
            SNP currentSNP = new SNP();

            // Tokenize current line using \t s
            StringTokenizer st = new StringTokenizer(currentLine, "\t");
            // While the line still has tokens
            while (st.hasMoreTokens()) {
                // Add rank, SNPid and Score values to the current SNP object
                currentSNP.setRank(Double.parseDouble(st.nextToken()));     // String to Double
                currentSNP.setSNPid(st.nextToken().trim());     // trim() to eliminate spaces
                // Raw score
                currentSNP.setScore(Double.parseDouble(st.nextToken()));    // String to Double
                // Number of genotyped SNPs -- thrown away
                st.nextToken();

                // Add current SNP in SNP list
                SNPList.add(currentSNP);
            }
        }
        // Adding the normalized scores in every SNP of the SNPList
        normalizeAndStoreSNPScoreValues(SNPList);
        return SNPList;
    }

    /**
     * Writing a ranking list in a file. Format key value, where key is a string and value a double value
     * @param map is the structure containing the key value pairs to be written in file
     */
    private void WriteToFile(Map<String, Double> map) {
        // Create file with the specific filename
        File outputFile = new File(outputFilename);
        // Create buffered writer
        BufferedWriter writer = null;
        try {
            // Connect the writer to the output file
            writer = new BufferedWriter(new FileWriter(outputFile));
            // Iterate through the input map
            for (Map.Entry<String, Double> entry : map.entrySet()) {
                // Write the key - value pair in the file with format: key value
                writer.write(entry.getKey() + " " + entry.getValue());
                // Add a new line to the file, for the next entry to be written on next line
                writer.newLine();
            }
        } catch (IOException e) {
            System.out.println("Writer appending failed");
            e.printStackTrace();
        }
        // Closing buffered writer
        finally {
            try {
                if (writer != null)
                    writer.close();
            } catch (IOException e) {
                System.out.println("Writer close problem");
                e.printStackTrace();
            }
        }
    }

    /**
     * Creates the proper Pre processing output. That is a Map of pairs with the SNPid as the key and one of the other SNP fields as value,
     * depending on the parameter set by the user
     * @param SNPList is the initial SNPList from which the map will be created
     * @param parameter is the parameter based on which the field to serve as value is chosen
     *                  0 is for SNP rank
     *                  1 is for SNP Score
     *                  2 is for normalized SNP Score
     *                  Rank is also used as default
     * @return a map with the ranking of the initial list with the form of (SNPid -> value[depends on parameter])
     */
    public Map<String, Double> formatOutput(List<SNP> SNPList, int parameter) {

        // Creating a linked hash map - output data structure
        Map<String, Double> outputSNPMap = new LinkedHashMap<>();

        // Choose which element of the SNP object to show in output
        switch(parameter){
            // SNP rank
            case 0:
                // Iterate through SNP list
                for (SNP currentSNP : SNPList) {
                    // Add SNP id and Rank in output Map (this map keeps the insertion order)
                    outputSNPMap.put(currentSNP.getSNPid(), currentSNP.getRank());
                }
                break;
            // SNP score
            case 1:
                // Iterate through SNP list
                for (SNP currentSNP : SNPList) {
                    // Add SNP id and Score in output Map (this map keeps the insertion order)
                    outputSNPMap.put(currentSNP.getSNPid(), currentSNP.getScore());
                }
                break;
            case 2:
                // Iterate through SNP list
                for (SNP currentSNP : SNPList) {
                    // Add SNP id and Rank in output Map (this map keeps the insertion order)
                    outputSNPMap.put(currentSNP.getSNPid(), currentSNP.getNormalizedScore());
                }
                break;
            // Using RANK as a default
            default:
                // Iterate through SNP list
                for (SNP currentSNP : SNPList) {
                    // Add SNP id and Rank in output Map (this map keeps the insertion order)
                    outputSNPMap.put(currentSNP.getSNPid(), currentSNP.getRank());
                }
                break;
        }
        return outputSNPMap;
    }

    /**
     * Normalises the scores of an SNPList and adds the normalized values in the respective object
     * @param SNPList is the list of SNPs whose normalized scores we want to compute and store
     */
    private void normalizeAndStoreSNPScoreValues(List<SNP> SNPList) {
        // Creating a temporary list that contains all the scores of the SNPs in the list
        List<Double> scoresList = new ArrayList<>();
        // Pair of values to store the range of the score values
        Pair<Double, Double> rangePair;

        // Iterating through SNP List
        for(SNP currentSNP : SNPList) {
            // Adding score in the temporary score only list
            scoresList.add(currentSNP.getScore());
        }

        // Finding the range of values of the scores of the list
        rangePair = findRange(scoresList);

        // Iterating through SNP List
        for(SNP currentSNP : SNPList) {
            // Computing the normalized score for each SNP and storing it in the respective SNP field
            currentSNP.setNormalizedScore(normaliseAValue(currentSNP.getScore(),rangePair.getKey(), rangePair.getValue()));
        }
    }

    /**
     * Helper function that normalises double values of any range to a [0.0, 1.0] range
     * @param currentValue the value to be normalised
     * @param minValue Minimum value of the initial range of the currentValue
     * @param maxValue Maximum value of the initial range of the currentValue
     * @return The value of the currentValue in the range [0.0, 1.0]
     */
    private Double normaliseAValue(Double currentValue, Double minValue, Double maxValue) {
        // Checking if the value given is in the initial range
        if(currentValue <= maxValue && currentValue >= minValue)
            // return the nomalized value of the initial score
            return (currentValue - minValue)/(maxValue - minValue);     // formula x' = (x - xmin)/(xmax - xmin)
        System.out.println("Value to be normalised cannot be larger than max value!");
        // Exit with code equal to 1 if the value to be normalized is out of bounds
        System.exit(1);
        return null;
    }

    /**
     * Helper function that finds the minimum and maximum value of a list and returns it as a Pair object
     * @param list is the list whose minimum and maximum value we're looking for
     * @return a Pair object Key: Minimum value
     *                       Value: Maximum value
     */
    private Pair<Double, Double> findRange (List<Double> list) {
        // Using collections methods to get minimum and maximum values
        return new Pair<>(Collections.min(list), Collections.max(list));
    }
}
